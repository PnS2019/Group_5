from __future__ import print_function, absolute_import
import numpy as np
import cv2
import imutils
from keras.models import load_model
from keras.utils import CustomObjectScope
from keras.initializers import glorot_uniform
from PIL import Image



#at first import desired image and convert it to a black and white
imagetobw = Image.open("testpicture.jpg")
thresh = 125 #has to be chosen wisely
fn = lambda x : 255 if x > thresh else 0
bwimage = imagetobw.convert('L').point(fn, mode = '1')
bwimage.save("hallo.jpg")
bwimage2 = cv2.imread("hallo.jpg", cv2.COLOR_BGR2GRAY)
bwimage3 = Image.open("hallo.jpg")
#if we use the bwimage without reimporting it, it's an object of a class from the Pillow extension

#basic commands to show picture
cv2.imshow("im3",bwimage2)
cv2.waitKey(0)
cv2.destroyWindow("im3")

image = cv2.imread("hallo.jpg")

#image rescalling, greyscale and edgemap and reducing noise with gaussian blur
image2 = imutils.resize(image,height=500)
gray = cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY)
blurred = cv2.GaussianBlur(gray, (5, 5), 0)
edged = cv2.Canny(blurred, 50, 200, 255)

#thresholds the picture
thresh = cv2.threshold(edged, 0, 255,cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]

#invert image to find contours
imagem = cv2.bitwise_not(thresh)

#gives back the contours
(cnts,_) = cv2.findContours(imagem, cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(image, cnts, -1, (240, 0, 159), 3)
cv2.imshow("Image", image)
cv2.waitKey(0)


#here we sort the contours from Left to right
i = 0
boundingBoxes = [cv2.boundingRect(c) for c in cnts]
(cnts3, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),key=lambda b: b[1][i], reverse=False))
aList = "";

#we go over all contours
for i in range(len(cnts3)):
    contours = cnts3[i]
    x, y, w, h = cv2.boundingRect(contours)
    # draws a rectangle around the number or sign
    im2 = cv2.rectangle(imagem, (x, y), (x + w, y + h), (0, 255, 0), 2)
    im3 = cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)

    if h > 30 or w > 30:
        # cropping to quadratic window with sidelength h if it's a number ( since there the height ist bigger than width) and w otherwise
        newh = int(1.5 * h)
        neww = int(1.5 * w)
        croppedtorect = bwimage3.crop((x-int(h*0.1), y-int(w*0.1), x+w, y+h))

        #we create a white image and put the number in it
        size = max(45,newh, neww)
        new_im = Image.new('L', (size, size), (255))
        new_im.paste(croppedtorect, (int(w/2), int(h*0.1)))

        new_im.save("hallo3.jpg")
        new_imc = cv2.imread("hallo3.jpg", cv2.COLOR_BGR2GRAY)

        # now resize it
        resimage = cv2.resize(new_imc, (45, 45), interpolation=cv2.INTER_CUBIC)
        newimage2 = np.expand_dims(resimage, axis=3)
        newimage1 = np.expand_dims(newimage2, axis=0)

        cv2.imshow("resimage", resimage)
        cv2.waitKey(0)

        # load trained model
        with CustomObjectScope({'GlorotUniform': glorot_uniform()}):
            model = load_model('shit_happens.hdf5')

        # models.predict takes 4 dim array with 10 images
        # prediction = model.predict(newimage2)
        preds = np.argmax(model.predict(newimage1), axis=1).astype(np.int)
        labels = ["8", "3", "1", "5", "/", "-", "*", "-", "9", "0", "+", "6", "7", "4", "2"]  # for shit_happens.hdf5

        print("It should be a: ")
        print(labels[preds[0]])

        aList = aList + (labels[preds[0]])
        cv2.imshow("im3", im3)
        cv2.waitKey(0)

print("the resulting computation is")
print(eval(aList))

cv2.destroyAllWindows()
