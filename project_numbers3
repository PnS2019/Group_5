from __future__ import print_function, absolute_import
import numpy as np
import cv2
import imutils
from keras.models import load_model
from keras.utils import CustomObjectScope
from keras.initializers import glorot_uniform
from PIL import Image


#at first import desired image and convert it to a black and white
imagetobw = Image.open("testpicture.jpg")
thresh = 110 #has to be chosen wisely                               #has to be choosen wisely
fn = lambda x : 255 if x > thresh else 0
bwimage = imagetobw.convert('L').point(fn, mode = '1')
bwimage.save("hallo.jpg")
bwimage2 = cv2.imread("hallo.jpg", cv2.COLOR_BGR2GRAY)  #if we use the bwimage without reimporting it, it's an object of a class from the Pillow extension

#basic commands to show picture
cv2.imshow("im3",bwimage2)
cv2.waitKey(0)
cv2.destroyWindow("im3")

image = cv2.imread("hallo.jpg")

#image rescalling, greyscale and edgemap and reducing noise with gaussian blur
image2 = imutils.resize(image,height=500)
gray = cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY)
blurred = cv2.GaussianBlur(gray, (5, 5), 0)
edged = cv2.Canny(blurred, 50, 200, 255)

#thresholds the picture
thresh = cv2.threshold(edged, 0, 255,cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]

#invert image to find contours
imagem = cv2.bitwise_not(thresh)

#gives back the contours
(cnts,_) = cv2.findContours(imagem, cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(image, cnts, -1, (240, 0, 159), 3)
cv2.imshow("Image", image)
cv2.waitKey(0)


#here we sort the contours from Left to right
i = 0
boundingBoxes = [cv2.boundingRect(c) for c in cnts]
(cnts3, boundingBoxes) = zip(*sorted(zip(cnts, boundingBoxes),key=lambda b: b[1][i], reverse=False))
aList = "";

#we go over all contours
for i in range(len(cnts3)):
    contours = cnts3[i]
    x, y, w, h = cv2.boundingRect(contours)
    # draws a rectangle around the number or sign
    im2 = cv2.rectangle(imagem, (x, y), (x + w, y + h), (0, 255, 0), 2)
    im3 = cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)

    # cropping to quadratic window with sidelength h if it's a number ( since there the height ist bigger than width) and w otherwise
    vers1 = int((h - w) / 2)
    #print(vers1)
    if h > w:
        crop_img = bwimage2[y:y + h, x - vers1:x + h - vers1]
    else:
        crop_img = bwimage2[y - vers1:y + w - vers1, x:x + w]

    # now resize it
    resimage = cv2.resize(crop_img, (45, 45), interpolation=cv2.INTER_CUBIC)
    newimage1 = np.expand_dims(resimage, axis=2)
    newimage2 = np.expand_dims(newimage1, axis=0)

    # load trained model
    with CustomObjectScope({'GlorotUniform': glorot_uniform()}):
        model = load_model('shit_happens.hdf5')

    # models.predict takes 4 dim array with 10 images
    # prediction = model.predict(newimage2)
    preds = np.argmax(model.predict(newimage2), axis=1).astype(np.int)
    #labels = ["=", "-", "+", "1", "2", "3","4","5","6","7","8","9","0","div","times"] # for numbers_trained.hdf5
    labels = ["8", "3", "1", "5", "/", "-", "*", "-", "9", "0", "+", "6", "7", "4", "2"]  # for shit_happens.hdf5

    print("It should be a: ")
    print(labels[preds[0]])

    aList = aList + (labels[preds[0]])

    cv2.imshow("im3", im3)
    cv2.waitKey(0)

print("the resulting computation is")
print(eval(aList))

cv2.destroyAllWindows()
